%==================================================================
% Ini adalah bab 1
% Silahkan edit sesuai kebutuhan, baik menambah atau mengurangi \section, \subsection
%==================================================================

\chapter[PENDAHULUAN]{\\ PENDAHULUAN}

\section{Latar Belakang Masalah}

% === Observability Evolution Narrative ===
Perkembangan teknologi \textit{cloud computing} telah mengubah fundamental organisasi dalam membangun dan mengoperasikan sistem perangkat lunak. Sistem modern yang berjalan di platform seperti Kubernetes dapat terdiri dari ratusan hingga ribuan \textit{container} yang saling berinteraksi, menciptakan kompleksitas operasional yang belum pernah terjadi sebelumnya \citep{CNCF_2024_Kubernetes}. Dalam konteks ini, praktik \textit{Site Reliability Engineering} (SRE) yang diperkenalkan oleh Google menjadi pendekatan standar untuk memastikan keandalan sistem berskala besar \citep{Beyer_2016_SRE}.

Untuk memahami dan mengelola sistem terdistribusi yang kompleks, konsep \textit{observability} telah berevolusi dari pemantauan tradisional menjadi pendekatan yang lebih komprehensif \citep{Sridharan_2018_Observability}. \textit{Observability} modern dibangun di atas tiga pilar utama: \textit{metrics} (data numerik tentang kondisi sistem), \textit{logs} (catatan kejadian terstruktur), dan \textit{traces} (pelacakan alur permintaan antar layanan) \citep{Picoreti_2018_Observability}. Namun, ketiga pilar ini memiliki keterbatasan ketika digunakan secara terpisah; \textit{metrics} tidak menjelaskan penyebab masalah, \textit{logs} sulit dikorelasikan lintas layanan, dan \textit{traces} memerlukan instrumentasi yang kompleks \citep{Soldani_2022_Observability}.

Arsitektur Kubernetes dan \textit{microservices} memperparah tantangan ini karena sifatnya yang dinamis dan terdistribusi. Sebuah permintaan pengguna dapat melewati puluhan layanan sebelum menghasilkan respons, dan kegagalan di satu komponen dapat memiliki efek domino ke seluruh sistem \citep{Burns_2018_Kubernetes}. Hal ini menciptakan kebutuhan mendesak akan \textit{unified observability}, yaitu kemampuan untuk mengkorelasikan data dari ketiga pilar secara otomatis untuk memahami kondisi sistem secara holistik.

% === AIOps State of the Art ===
Untuk mengatasi kompleksitas ini, industri telah mengembangkan solusi \textit{Artificial Intelligence for IT Operations} (AIOps) yang menerapkan teknik \textit{machine learning} untuk mengotomatiskan tugas-tugas operasional \citep{Notaro_2021_AIOps}. Platform komersial seperti Datadog, Dynatrace, dan Splunk menawarkan kemampuan deteksi anomali, korelasi kejadian, dan prediksi kegagalan berbasis AI \citep{Dang_2019_AIOps}. Namun, solusi-solusi ini memiliki keterbatasan fundamental yang menghambat adopsi dan efektivitasnya.

Pertama, arsitektur AIOps saat ini bersifat \textit{monolithic}—menggabungkan \textit{data ingestion}, analisis, dan aksi dalam satu platform \textit{vendor} tunggal \citep{Lyu_2021_AIOps}. Organisasi tidak dapat dengan mudah mengganti atau menggabungkan komponen dari \textit{vendor} berbeda untuk mendapatkan solusi terbaik. Kedua, masalah \textit{vendor lock-in} membuat organisasi bergantung pada ekosistem tertutup, mengurangi fleksibilitas dan meningkatkan biaya jangka panjang.

% === MCP/A2A Standards Emergence ===
Menanggapi kebutuhan akan interoperabilitas, standar komunikasi baru untuk agen AI telah muncul. \textit{Model Context Protocol} (MCP) yang dikembangkan oleh Anthropic menyediakan antarmuka standar bagi agen untuk mengakses konteks dari peralatan-peralatan lain, seperti data dari Kubernetes, Prometheus, atau sistem \textit{logging}, tanpa perlu implementasi API spesifik untuk setiap sumber data \citep{LFProjectsLLC_2025_MCP}. Sementara itu, protokol \textit{Agent-to-Agent} (A2A) dari Google memungkinkan komunikasi terstruktur antar agen yang berbeda, terlepas dari \textit{framework} atau bahasa pemrograman yang digunakan \citep{Google_2024_A2A}.

Kemunculan protokol-protokol ini menandai pergeseran paradigma dari sistem AI yang terisolasi menuju ekosistem agen yang dapat berinteroperasi \citep{Xi_2023_LLMAgents}. Beberapa \textit{framework} pengembangan agen telah mengadopsi standar ini, misalnya Google Agent Development Kit (ADK) dan LangChain yang telah mendukung integrasi dengan MCP dan A2A secara \textit{native} \citep{Google_2024_ADK, LangChain_2024}.

% === Accessibility Gap ===
Meskipun standar komunikasi telah tersedia dan diadopsi oleh \textit{framework} modern, terdapat kesenjangan signifikan dalam aksesibilitas. Semua \textit{framework} agen yang ada saat ini, termasuk Google ADK dan LangChain, memerlukan keahlian pemrograman yang substansial untuk digunakan. Pengembang harus memahami pola-pola SDK, menulis kelas agen dalam bahasa pemrograman Python atau JavaScript, mengimplementasikan \textit{binding} untuk \textit{tools}, dan mengelola logika koordinasi yang kompleks, semuanya dalam kode \citep{LangChain_2024}.

Situasi ini menciptakan hambatan masuk (\textit{entry barrier}) yang tinggi ke era agentik. Pakar bidang tertentu seperti praktisi SRE, analis data, atau tim operasional yang memahami alur kerja bidang spesifik mereka dengan baik, tidak dapat membangun aplikasi agentik tanpa terlebih dahulu menjadi pengembang perangkat lunak. Terdapat dilema pilihan yang semu (\textit{false choice}): menerima keterbatasan alat \textit{no-code} yang sederhana, atau berkomitmen untuk menguasai pemrograman secara penuh. Tidak ada \textit{framework} yang menawarkan kesederhanaan deklaratif dengan ekstensibilitas berbasis standar.

% === Multi-Agent Systems Foundation ===
Dari perspektif teoritis, sistem multi-agen (\textit{Multi-Agent Systems}/MAS) telah dipelajari secara ekstensif dalam literatur kecerdasan buatan. \cite{Wooldridge_2009_MAS} mendefinisikan agen sebagai entitas yang otonom, reaktif terhadap lingkungan, proaktif dalam mencapai tujuan, dan mampu berinteraksi secara sosial dengan agen lain. \cite{Jennings_1998_MAS} memetakan berbagai paradigma koordinasi agen, termasuk sistem \textit{blackboard}, \textit{contract nets}, dan dekomposisi tugas hierarkis.

Literatur sistem multi-agen menawarkan berbagai pola koordinasi seperti \textit{supervisor}, \textit{blackboard}, dan \textit{contract nets} \citep{Jennings_1998_MAS}. LEAF mengadopsi pendekatan yang fleksibel: menyediakan pola orkestrasi bawaan yang umum digunakan (\textit{supervisor}, \textit{sequential}, \textit{parallel}) sambil memungkinkan implementasi pola kustom melalui mekanisme ekstensibilitas A2A. Pendekatan ini memisahkan keputusan protokol (yang diopinikan oleh LEAF) dari keputusan pola koordinasi (yang diserahkan kepada pengguna sesuai kebutuhan domain).

% === LEAF Framework Introduction ===
Berdasarkan analisis kesenjangan di atas, penelitian ini mengusulkan \textbf{LEAF} (\textit{Low-code Extensible Agentic Framework})—sebuah \textit{framework} agentik \textit{low-code} yang dirancang untuk mendemokratisasi pengembangan aplikasi multi-agen. LEAF menggunakan pendekatan deklaratif berbasis manifes YAML/JSON, analog dengan cara Kubernetes mengabstraksi manajemen infrastruktur melalui konfigurasi deklaratif \citep{Burns_2018_Kubernetes, Morris_2020_IaC, Artac_2017_DevOps}.

Kontribusi utama LEAF adalah menyediakan model kompleksitas progresif (\textit{progressive complexity model}) dengan tiga tingkat:
\begin{enumerate}
    \item \textbf{Level 1 (Deklaratif Murni)}: Pengguna mendefinisikan agen sepenuhnya dalam YAML, mereferensikan \textit{tools} MCP dari komunitas, tanpa perlu menulis kode sama sekali.
    \item \textbf{Level 2 (Deklaratif + Referensi)}: Manifes YAML dapat mereferensikan agen A2A eksternal atau server MCP kustom yang dikembangkan secara terpisah.
    \item \textbf{Level 3 (Implementasi Kustom)}: Pengembang yang memerlukan kontrol penuh dapat menulis agen kustom menggunakan LEAF SDK, yang tetap dapat berinteroperasi melalui standar A2A/MCP.
\end{enumerate}

Dengan demikian, standar MCP/A2A berfungsi sebagai "\textit{escape hatch}"—memungkinkan kesederhanaan \textit{low-code} tanpa menjadi pembatas yang mengekang. Pakar domain dapat memulai dengan konfigurasi deklaratif untuk kasus penggunaan umum (Level 1), kemudian berkembang sesuai kebutuhan tanpa harus memulai dari awal.

% === LEAF Architecture Overview ===
Arsitektur LEAF dibangun di atas konsep "\textit{Opinionated Grid}" yang memisahkan penalaran AI (\textit{reasoning}) dari pipa infrastruktur (\textit{plumbing}) melalui protokol komunikasi terstandarisasi: \textit{Southbound} (MCP untuk akses \textit{tools}), \textit{Northbound} (A2A untuk interaksi pengguna), dan \textit{East-West} (A2A untuk koordinasi antar agen). Detail arsitektur grid dijelaskan lebih lanjut pada Bab II \citep{LFProjectsLLC_2025_MCP, Google_2024_A2A}.

LEAF mengorganisasi agen dalam taksonomi empat lapis dengan hierarki \textit{Orchestrator} $\rightarrow$ \textit{Processor} $\rightarrow$ \textit{Sensor}/\textit{Executor}. \textit{Orchestrator} sendiri merupakan tipe agen yang mengoordinasi agen-agen \textit{Processor}, yang kemudian mengelola agen \textit{Sensor} (pengumpulan data) dan \textit{Executor} (implementasi aksi). LEAF menyediakan pola orkestrasi bawaan: \textit{supervisor} (perutean dinamis berbasis LLM), \textit{sequential} (\textit{pipeline} berurutan), dan \textit{parallel} (eksekusi bersamaan). Pengguna dapat mengimplementasikan pola kustom melalui mekanisme Level 2/3.

Pada lapisan \textit{tools}, LEAF membedakan kapabilitas \textit{sensor} (operasi baca) dan kapabilitas \textit{executor} (operasi tulis/mutasi). Pembatasan ini ditegakkan pada lapisan agen: agen \textit{Sensor} hanya dapat menggunakan kapabilitas baca, sedangkan agen \textit{Executor} hanya dapat menggunakan kapabilitas mutasi. Sebagai prinsip desain inti, LEAF menekankan pengawasan manusia (\textit{human-in-the-loop}); berdasarkan pedoman interaksi manusia-AI \citep{Amershi_2019_HITL, Shneiderman_2020_HCAI}, semua aksi \textit{Executor} memerlukan persetujuan eksplisit sebelum dieksekusi.

% === Research Contribution ===
Kontribusi penelitian ini adalah sebagai \textit{framework} agentik \textit{low-code} pertama yang menggabungkan desain berbasis manifes deklaratif dengan ekstensibilitas berbasis standar (MCP/A2A). LEAF memungkinkan pakar domain untuk membangun sistem multi-agen tanpa pemrograman, sambil mempertahankan "\textit{escape hatch}" untuk kustomisasi lanjutan oleh pengembang. Penelitian ini mencakup: (1) cetak biru arsitektur, (2) spesifikasi manifes deklaratif (JSON Schema), dan (3) implementasi referensi.

\textbf{Ruang Lingkup Tesis}: Meskipun LEAF dirancang sebagai \textit{framework} tujuan umum yang dapat diterapkan pada domain apa pun yang memerlukan koordinasi multi-agen (misalnya pengembangan perangkat lunak, \textit{pipeline} data, otomatisasi bisnis), tesis ini secara spesifik berfokus pada \textbf{\textit{observability} Kubernetes dan operasi SRE} sebagai studi kasus implementasi untuk memvalidasi pola-pola inti \textit{framework}.

\section{Identifikasi Masalah}
Berdasarkan latar belakang yang telah diuraikan, dapat diidentifikasi beberapa permasalahan sebagai berikut:
\begin{enumerate}
    \item Kompleksitas sistem \textit{cloud computing} modern, khususnya arsitektur Kubernetes dan \textit{microservices}, menciptakan tantangan \textit{observability} yang sulit diatasi dengan pendekatan pemantauan tradisional.
    \item Arsitektur platform AIOps yang bersifat \textit{monolithic} menyebabkan \textit{vendor lock-in}, membatasi fleksibilitas organisasi dalam mengadopsi solusi terbaik dari berbagai penyedia.
    \item \textit{Framework} agentik yang ada saat ini memerlukan keahlian pemrograman yang substansial, menciptakan hambatan masuk (\textit{entry barrier}) yang tinggi bagi pakar domain non-programmer.
    \item Tidak tersedia pendekatan deklaratif/\textit{low-code} pada \textit{framework} agentik yang ada, memaksa pengguna memilih antara kesederhanaan tanpa fleksibilitas atau fleksibilitas dengan kompleksitas tinggi.
    \item Meskipun standar komunikasi agen (MCP, A2A) telah tersedia, adopsi praktis dalam bentuk \textit{framework} yang mudah digunakan masih terbatas.
\end{enumerate}

\section{Batasan Masalah}
Dari berbagai masalah yang teridentifikasi, penelitian ini membatasi ruang lingkup pada aspek-aspek berikut:
\begin{enumerate}
    \item Penelitian berfokus pada pendekatan agentik berbasis \textit{Large Language Model} (LLM), bukan pada \textit{pipeline machine learning} tradisional atau sistem berbasis aturan.
    \item \textit{Framework} yang dikembangkan menggunakan pendekatan \textit{low-code} dengan manifes deklaratif (YAML/JSON), bukan antarmuka \textit{no-code} berbasis GUI.
    \item Validasi dan implementasi referensi difokuskan pada domain \textit{observability} Kubernetes dan operasi SRE sebagai studi kasus, meskipun \textit{framework} dirancang untuk tujuan umum.
    \item Ekstensibilitas \textit{framework} dibangun di atas protokol standar MCP dan A2A, tidak mengembangkan protokol komunikasi proprietary baru.
\end{enumerate}
Pembatasan pada domain Kubernetes/SRE dipilih karena kompleksitas yang representatif dan ketersediaan infrastruktur pengujian, sementara masalah kompleksitas \textit{observability} secara umum telah ditangani oleh berbagai alat yang ada.

\section{Rumusan Masalah}
Berdasarkan identifikasi dan batasan masalah di atas, rumusan masalah dalam penelitian ini adalah:
\begin{enumerate}
    \item Bagaimana merancang arsitektur \textit{framework} agentik \textit{low-code} yang memanfaatkan protokol standar MCP dan A2A untuk interoperabilitas?
    \item Bagaimana menyusun spesifikasi format manifes deklaratif yang memungkinkan definisi agen tanpa pemrograman?
    \item Bagaimana mengimplementasikan dan memvalidasi \textit{framework} tersebut pada domain \textit{observability} Kubernetes dan operasi SRE?
\end{enumerate}

\section{Tujuan Penelitian}
Sesuai dengan rumusan masalah yang telah ditetapkan, tujuan penelitian ini adalah:
\begin{enumerate}
    \item Merancang arsitektur \textit{framework} agentik \textit{low-code} berbasis protokol MCP dan A2A yang memungkinkan interoperabilitas antar komponen.
    \item Menyusun spesifikasi format manifes deklaratif (JSON Schema) untuk definisi agen, \textit{tools}, dan orkestrasi tanpa memerlukan pemrograman.
    \item Mengimplementasikan dan memvalidasi \textit{framework} LEAF melalui studi kasus aplikasi \textit{observability} Kubernetes dan operasi SRE.
\end{enumerate}

\section{Manfaat Penelitian}
Hasil penelitian ini diharapkan dapat memberikan manfaat baik secara teoritis maupun praktis.

\subsection{Manfaat Teoritis}
\begin{enumerate}
    \item Memberikan kontribusi pada pengembangan pola desain \textit{framework} agentik \textit{low-code}, memperkaya literatur di bidang sistem multi-agen dan \textit{human-computer interaction}.
    \item Menyediakan arsitektur referensi untuk menggabungkan paradigma deklaratif dengan standar komunikasi agen (MCP/A2A), yang dapat menjadi dasar penelitian lanjutan.
\end{enumerate}

\subsection{Manfaat Praktis}
\begin{enumerate}
    \item Bagi praktisi SRE dan tim operasional: menyediakan alat yang memungkinkan pembangunan sistem \textit{observability} berbasis agen tanpa memerlukan keahlian pemrograman mendalam.
    \item Bagi organisasi: mengurangi hambatan adopsi otomatisasi agentik, memungkinkan pakar domain untuk langsung berkontribusi dalam pengembangan solusi.
    \item Bagi komunitas akademik UNY: menyediakan implementasi referensi yang dapat digunakan untuk penelitian dan pengembangan lebih lanjut di bidang sistem multi-agen dan AIOps.
\end{enumerate}
