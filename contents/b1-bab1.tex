%==================================================================
% Ini adalah bab 1
% Silahkan edit sesuai kebutuhan, baik menambah atau mengurangi \section, \subsection
%==================================================================

\chapter[PENDAHULUAN]{\\ PENDAHULUAN}

\section{Latar Belakang}

% === Observability Evolution Narrative ===
Perkembangan teknologi \textit{cloud computing} dan arsitektur \textit{microservices} telah mengubah secara fundamental cara organisasi membangun dan mengoperasikan sistem perangkat lunak \cite{Burns_2016_Borg}. Sistem modern yang berjalan di platform seperti Kubernetes dapat terdiri dari ratusan hingga ribuan \textit{container} yang saling berinteraksi, menciptakan kompleksitas operasional yang belum pernah terjadi sebelumnya \cite{CNCF_2024_Kubernetes}. Dalam konteks ini, praktik \textit{Site Reliability Engineering} (SRE) yang diperkenalkan oleh Google menjadi pendekatan standar untuk memastikan keandalan sistem berskala besar \cite{Beyer_2016_SRE}.

Untuk memahami dan mengelola sistem terdistribusi yang kompleks, konsep \textit{observability} telah berevolusi dari pemantauan tradisional menjadi pendekatan yang lebih komprehensif \cite{Sridharan_2018_Observability}. \textit{Observability} modern dibangun di atas tiga pilar utama: \textit{metrics} (data numerik tentang kondisi sistem), \textit{logs} (catatan kejadian terstruktur), dan \textit{traces} (pelacakan alur permintaan antar layanan) \cite{Picoreti_2018_Observability}. Namun, ketiga pilar ini memiliki keterbatasan ketika digunakan secara terpisah—\textit{metrics} tidak menjelaskan penyebab masalah, \textit{logs} sulit dikorelasikan lintas layanan, dan \textit{traces} memerlukan instrumentasi yang kompleks \cite{Soldani_2022_Observability}.

Arsitektur Kubernetes dan \textit{microservices} memperparah tantangan ini karena sifatnya yang dinamis dan terdistribusi. Sebuah permintaan pengguna dapat melewati puluhan layanan sebelum menghasilkan respons, dan kegagalan di satu komponen dapat berdampak kaskade ke seluruh sistem \cite{Burns_2018_Kubernetes}. Hal ini menciptakan kebutuhan mendesak akan \textit{unified observability}—kemampuan untuk mengkorelasikan data dari ketiga pilar secara otomatis untuk memahami kondisi sistem secara holistik.

% === AIOps State of the Art ===
Untuk mengatasi kompleksitas ini, industri telah mengembangkan solusi \textit{Artificial Intelligence for IT Operations} (AIOps) yang menerapkan teknik \textit{machine learning} untuk mengotomatisasi tugas-tugas operasional \cite{Notaro_2021_AIOps}. Platform komersial seperti Datadog, Dynatrace, dan Splunk AIOps menawarkan kemampuan deteksi anomali, korelasi kejadian, dan prediksi kegagalan berbasis AI \cite{Dang_2019_AIOps}. Namun, solusi-solusi ini memiliki keterbatasan fundamental yang menghambat adopsi dan efektivitasnya.

Pertama, arsitektur AIOps saat ini bersifat \textit{monolithic}—menggabungkan \textit{data ingestion}, analisis, dan aksi dalam satu platform \textit{vendor} tunggal \cite{Lyu_2021_AIOps}. Organisasi tidak dapat dengan mudah mengganti atau menggabungkan komponen dari \textit{vendor} berbeda untuk mendapatkan solusi terbaik. Kedua, masalah \textit{vendor lock-in} membuat organisasi bergantung pada ekosistem tertutup, mengurangi fleksibilitas dan meningkatkan biaya jangka panjang.

% === MCP/A2A Standards Emergence ===
Menanggapi kebutuhan akan interoperabilitas, standar komunikasi baru untuk agen AI telah muncul. \textit{Model Context Protocol} (MCP) yang dikembangkan oleh Anthropic menyediakan antarmuka standar bagi agen untuk mengakses konteks lingkungan—seperti data dari Kubernetes, Prometheus, atau sistem \textit{logging}—tanpa perlu implementasi API spesifik untuk setiap sumber data \cite{Anthropic_2024_MCP}. Sementara itu, protokol \textit{Agent-to-Agent} (A2A) dari Google memungkinkan pertukaran tugas terstruktur antar agen heterogen, terlepas dari \textit{framework} atau bahasa pemrograman yang digunakan \cite{Google_2024_A2A}.

Kemunculan protokol-protokol ini menandai pergeseran paradigma dari sistem AI yang terisolasi menuju ekosistem agen yang dapat berinteroperasi \cite{Xi_2023_LLMAgents}. Beberapa \textit{framework} pengembangan agen telah mengadopsi standar ini: Google Agent Development Kit (ADK) mendukung A2A secara native \cite{Google_2024_ADK}, LangChain menyediakan integrasi dengan MCP \cite{LangChain_2024}, dan CrewAI memungkinkan orkestrasi multi-agen dengan dukungan protokol standar \cite{CrewAI_2024}.

% === Accessibility Gap ===
Meskipun standar komunikasi telah tersedia dan diadopsi oleh \textit{framework} modern, terdapat kesenjangan signifikan dalam aksesibilitas. Semua \textit{framework} agen yang ada saat ini—termasuk Google ADK, LangChain, dan CrewAI—memerlukan keahlian pemrograman yang substansial untuk digunakan. Pengembang harus memahami pola-pola SDK, menulis kelas agen dalam Python atau JavaScript, mengimplementasikan \textit{binding} untuk \textit{tools}, dan mengelola logika koordinasi yang kompleks—semuanya dalam kode \cite{LangChain_2024, CrewAI_2024}.

Situasi ini menciptakan hambatan masuk (\textit{entry barrier}) yang tinggi ke era agentik. Pakar domain seperti praktisi SRE, analis data, atau tim operasional yang memahami alur kerja mereka dengan baik tidak dapat membangun aplikasi agentik tanpa terlebih dahulu menjadi pengembang perangkat lunak. Terdapat dilema pilihan yang semu (\textit{false choice}): menerima keterbatasan alat \textit{no-code} yang sederhana, atau berkomitmen untuk menguasai pemrograman secara penuh. Tidak ada \textit{framework} yang menawarkan kesederhanaan deklaratif dengan ekstensibilitas berbasis standar.

% === Multi-Agent Systems Foundation ===
Dari perspektif teoritis, sistem multi-agen (\textit{Multi-Agent Systems}/MAS) telah dipelajari secara ekstensif dalam literatur kecerdasan buatan. Wooldridge \cite{Wooldridge_2009_MAS} mendefinisikan agen sebagai entitas yang otonom, reaktif terhadap lingkungan, proaktif dalam mencapai tujuan, dan mampu berinteraksi sosial dengan agen lain. Jennings et al. \cite{Jennings_1998_MAS} memetakan berbagai paradigma koordinasi agen, termasuk sistem \textit{blackboard}, \textit{contract nets}, dan dekomposisi tugas hierarkis.

Paradigma \textit{blackboard} khususnya relevan untuk koordinasi agen dalam konteks \textit{observability}. Seperti dijelaskan oleh Corkill \cite{Corkill_1991_Blackboard}, sistem \textit{blackboard} menyediakan ruang kerja bersama di mana agen-agen spesialis dapat berkontribusi secara inkremental untuk memecahkan masalah kompleks. Pendekatan ini mengatasi masalah \textit{context bloat}—di mana pengiriman data mentah antar agen menyebabkan \textit{overflow} token dan inefisiensi—dengan memungkinkan agen berbagi \textit{pointer} ke \textit{state} daripada data itu sendiri.

% === LEAF Framework Introduction ===
Berdasarkan analisis kesenjangan di atas, penelitian ini mengusulkan \textbf{LEAF} (\textit{Low-code Extensible Agentic Framework})—sebuah \textit{framework} agentik \textit{low-code} yang dirancang untuk mendemokratisasi pengembangan aplikasi multi-agen. LEAF menggunakan pendekatan deklaratif berbasis manifes YAML/JSON, analog dengan cara Kubernetes mengabstraksi manajemen infrastruktur melalui konfigurasi deklaratif \cite{Burns_2018_Kubernetes, Morris_2020_IaC, Artac_2017_DevOps}.

Kontribusi utama LEAF adalah menyediakan model kompleksitas progresif (\textit{progressive complexity model}) dengan tiga tingkat:
\begin{enumerate}
    \item \textbf{Level 1 (Deklaratif Murni)}: Pengguna mendefinisikan agen sepenuhnya dalam YAML, mereferensikan \textit{tools} MCP dari komunitas, tanpa perlu menulis kode sama sekali.
    \item \textbf{Level 2 (Deklaratif + Referensi)}: Manifes YAML dapat mereferensikan agen A2A eksternal atau server MCP kustom yang dikembangkan secara terpisah.
    \item \textbf{Level 3 (Implementasi Kustom)}: Pengembang yang memerlukan kontrol penuh dapat menulis agen kustom menggunakan LEAF SDK, yang tetap dapat berinteroperasi melalui standar A2A/MCP.
\end{enumerate}

Dengan demikian, standar MCP/A2A berfungsi sebagai "\textit{escape hatch}"—memungkinkan kesederhanaan \textit{low-code} tanpa menjadi pembatas yang mengekang. Pakar domain dapat memulai dengan konfigurasi deklaratif untuk kasus penggunaan umum (Level 1), kemudian berkembang sesuai kebutuhan tanpa harus memulai dari awal.

% === LEAF Architecture Overview ===
Arsitektur LEAF dibangun di atas konsep "\textit{Opinionated Grid}" yang memisahkan penalaran AI (\textit{reasoning}) dari pipa infrastruktur (\textit{plumbing}) melalui protokol komunikasi terstandarisasi. Grid ini mendefinisikan tiga arah komunikasi: \textit{Southbound} (menggunakan MCP untuk query konteks lingkungan), \textit{Northbound} (menggunakan A2A untuk komunikasi dengan pengguna), dan \textit{East-West} (menggunakan A2A untuk koordinasi antar agen) \cite{Anthropic_2024_MCP, Google_2024_A2A}.

LEAF mengorganisasi agen dalam taksonomi empat lapis: \textit{Orchestrator} (perencanaan dan koordinasi), \textit{Sensor} (pengumpulan data), \textit{Processor} (analisis dan inferensi), dan \textit{Executor} (implementasi aksi). Untuk koordinasi, LEAF mengadopsi pola \textit{Blackboard} yang memungkinkan agen berbagi \textit{state pointer} (URI) ke penyimpanan versi terpusat, menghindari \textit{context bloat} \cite{Corkill_1991_Blackboard, Dorri_2018_MAS}.

Sebagai prinsip desain inti, LEAF menekankan pengawasan manusia (\textit{human-in-the-loop}) untuk semua aksi yang mengubah sistem. Berdasarkan pedoman interaksi manusia-AI \cite{Amershi_2019_HITL, Shneiderman_2020_HCAI}, semua aksi \textit{Executor} memerlukan persetujuan eksplisit dari manusia sebelum dieksekusi. Selain itu, pola \textit{Reflector agent} menyediakan verifikasi independen terhadap temuan sebelum aksi diambil.

% === Research Contribution ===
Kontribusi penelitian ini adalah sebagai \textit{framework} agentik \textit{low-code} pertama yang menggabungkan desain berbasis manifes deklaratif dengan ekstensibilitas berbasis standar (MCP/A2A). LEAF memungkinkan pakar domain untuk membangun sistem multi-agen tanpa pemrograman, sambil mempertahankan "\textit{escape hatch}" untuk kustomisasi lanjutan oleh pengembang. Penelitian ini mencakup: (1) cetak biru arsitektur, (2) spesifikasi manifes deklaratif (JSON Schema), dan (3) implementasi referensi.

\textbf{Ruang Lingkup Tesis}: Meskipun LEAF dirancang sebagai \textit{framework} tujuan umum yang dapat diterapkan pada domain apa pun yang memerlukan koordinasi multi-agen (misalnya pengembangan perangkat lunak, \textit{pipeline} data, otomatisasi bisnis), tesis ini secara spesifik berfokus pada \textbf{\textit{observability} Kubernetes dan operasi SRE} sebagai studi kasus implementasi untuk memvalidasi pola-pola inti \textit{framework}.

\section{Rumusan Masalah}
Rumusan masalah adalah langkah penting yang merangkum permasalahan spesifik atau kebutuhan yang menjadi dasar pengembangan proyek. Pada bagian ini, dijelaskan permasalahan utama yang dihadapi, seperti keterbatasan pada sistem atau perangkat yang sudah ada, atau kebutuhan baru yang belum terpenuhi oleh teknologi saat ini. Identifikasi masalah juga mencakup tantangan teknis, fungsional, atau ekonomi yang menjadi penghambat dan bagaimana proyek ini diharapkan dapat menjawab permasalahan tersebut. Fokusnya adalah memberikan pemahaman yang jelas mengenai alasan pentingnya mengembangkan proyek ini sebagai solusi yang dibutuhkan.

\section{Tujuan Proyek}
Tujuan proyek menyatakan secara spesifik hasil atau capaian yang diinginkan dari pengembangan proyek ini. Bagian ini dirancang untuk memastikan bahwa proyek memiliki sasaran yang jelas dan terukur. Tujuan tersebut dirumuskan berdasarkan masalah yang telah diidentifikasi dan mencakup pencapaian tertentu, seperti peningkatan kinerja sistem, efisiensi, atau kemudahan penggunaan yang diharapkan. Selain itu, tujuan proyek dapat berupa pengembangan prototipe, penerapan teknologi tertentu, atau pencapaian fungsionalitas baru yang belum ada. Penjabaran tujuan yang jelas membantu menjaga fokus proyek dan memberikan arah yang tepat dalam setiap tahapan pengembangan.

\section{Manfaat Proyek}
Manfaat proyek menguraikan dampak positif yang diharapkan dari hasil proyek ini bagi pengguna, industri, atau masyarakat secara umum. Manfaat ini mencakup berbagai aspek, seperti kontribusi terhadap peningkatan produktivitas, pengurangan biaya, peningkatan kualitas, atau kemudahan dalam penggunaan teknologi. Selain manfaat langsung, proyek ini juga diharapkan memiliki dampak jangka panjang yang bermanfaat, seperti mendorong inovasi di bidang terkait atau membuka peluang baru untuk pengembangan lebih lanjut. Dengan menjelaskan manfaat proyek, pembaca dapat memahami nilai tambah yang dihadirkan oleh proyek ini.

\section{Batasan Proyek}
Batasan proyek mengidentifikasi cakupan dan batasan ruang lingkup pengembangan sistem atau perangkat yang dirancang. Bagian ini mencakup aspek-aspek yang akan menjadi fokus utama dalam pengembangan serta aspek yang akan dikecualikan dari lingkup proyek. Penjelasan batasan ini penting agar proyek tetap terarah dan tidak meluas ke aspek-aspek yang berada di luar tujuan awal. Batasan proyek juga mencakup keterbatasan teknis, waktu, atau sumber daya yang mempengaruhi desain dan implementasi sistem. Dengan menetapkan batasan, proyek ini dapat lebih terfokus dan efisien dalam pencapaiannya.

\section{Keaslian Gagasan}
Keaslian gagasan bertujuan untuk menekankan inovasi atau kontribusi unik yang ditawarkan oleh proyek ini. Bagian ini menjelaskan bagaimana proyek ini menawarkan pendekatan yang berbeda atau peningkatan dibandingkan dengan metode atau perangkat yang sudah ada. Keaslian gagasan dapat diperlihatkan melalui perbandingan dengan proyek atau produk serupa, menunjukkan perbedaan signifikan atau keunggulan yang dihadirkan oleh solusi yang diusulkan. Misalnya, peningkatan kinerja, efisiensi, atau kemudahan penggunaan yang dihasilkan dari metode atau pendekatan baru. Selain itu, bagian ini juga bisa mencakup penggunaan teknologi atau desain yang belum banyak diterapkan dalam konteks yang sama. Penekanan pada keaslian gagasan membantu menunjukkan bahwa proyek ini tidak hanya mengikuti pola yang sudah ada, tetapi juga menghadirkan sesuatu yang baru dan relevan.

\section{Sistematika Penulisan}
Sistematika penulisan memberikan panduan mengenai struktur dari keseluruhan laporan proyek ini, sehingga memudahkan pembaca dalam memahami alur isi laporan dari setiap bab. Bagian ini menjelaskan isi dari setiap bab secara singkat, mulai dari latar belakang hingga kesimpulan dan rekomendasi. Misalnya, BAB I membahas pendahuluan dan dasar pengembangan proyek, BAB II menguraikan tinjauan pustaka dan landasan teori, dan seterusnya. Dengan memberikan sistematika penulisan, pembaca dapat memahami bagaimana laporan ini disusun secara keseluruhan dan bagaimana setiap bab saling berkaitan dalam mencapai tujuan akhir proyek.